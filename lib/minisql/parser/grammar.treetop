module MiniSQL

grammar SQL do

  rule expression do
      create_table_exp / drop_table_exp / create_index_exp / drop_index_exp / select_exp
  end

######

  rule create_table_exp do
    _? CREATE _ TABLE _ name _? '(' _?
      column_seq
      primary_key_exp
    ')' _? ';' _? {
        def compile
          rst={}
          rst[:name]=name.compile
          rst[:columns]=column_seq.compile
          rst[:primary_key]=primary_key_exp.compile
          [ :create_table, rst ]
        end
    }
  end

  rule column_seq do
    column_exp+ {
      def compile
        elements.map { |e| e.compile }
      end
    }
  end

  rule column_exp do
    _? name _ type:(int_or_float / char_type) unique:(_ UNIQUE)? _? ',' _? {
      def compile
        rst = { :name => name.compile }
        rst.merge! type.compile
        rst[:unique] = true unless unique.text_value.empty?
        rst
      end
    }
  end

  rule primary_key_exp do
    _? PRIMARY _ KEY _? '(' _? name _? ')' _? {
      def compile
        name.compile
      end
    }
  end

  rule int_or_float do
    (INT / FLOAT) {
      def compile
        { :type => text_value.downcase.to_sym }
      end
    }
  end

  rule char_type do
    _? CHAR _? '(' _? number _? ')' _? {
      def compile
        { :type => :char, :length => number.text_value.to_i }
      end
    }
  end

######

  rule drop_table_exp do
    _? DROP _ TABLE _ name _? ';' _? {
      def compile
        [ :drop_table, name.compile ]
      end
    }
  end

######

  rule create_index_exp do
    _? CREATE _ INDEX _ index:name _ ON _ table:name _?
    '(' _? column:name _? ')' _? ';' _? {
      def compile
        [ :create_index,
          { :name => index.compile,
            :table => table.compile,
            :column => column.compile
          }
        ]
      end
    }
  end

######

  rule drop_index_exp do
    _? DROP _ INDEX _ index:name _? ';' _? {
      def compile
        [ :drop_index, index.compile ]
      end
    }
  end

######

  rule select_exp do
    _? SELECT _ columns:(star / name_seq) _ FROM _ name _? ';' _? {
      def compile
        [ :select,
          { :table => name.compile,
            :columns => columns.compile
          }
        ]
      end
    }
  end

  rule star do
    '*' {
      def compile
        :*
      end
    }
  end

######

  rule name_seq do
    head:name _? tail:(',' _? name)* {
      def compile
        [ head.compile, *tail.elements.map{|e| e.name.compile} ]
      end
    }
  end

  rule name do
    [a-zA-Z_] [0-9a-zA-Z_]* {
      def compile
        text_value.to_sym
      end
    }
  end

  rule number do
    [1-9] [0-9]*
  end

  rule _ do
    [ \n\r\t]+
  end


  rule CHAR do 'char' / 'CHAR' end
  rule CREATE do 'create' / 'CREATE' end
  rule DROP do 'drop' / 'DROP' end
  rule FLOAT do 'float' / 'FLOAT' end
  rule FROM  do 'from' / 'FROM' end
  rule INDEX do 'index' / 'INDEX' end
  rule INT do 'int' / 'INT' end
  rule KEY do 'key' / 'KEY' end
  rule ON do 'on' / 'ON' end
  rule PRIMARY do 'primary' / 'PRIMARY' end
  rule SELECT do 'select' / 'SELECT' end
  rule TABLE do 'table' / 'TABLE' end
  rule UNIQUE do 'unique' / 'UNIQUE' end

end

end

# vim: filetype=ruby
