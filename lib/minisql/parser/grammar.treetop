module MiniSQL

grammar SQL do

  rule expression do
      create_table_exp / drop_table_exp / create_index_exp / drop_index_exp / select_exp
  end

######

  rule create_table_exp do
    _? CREATE _ TABLE _ name _? '(' _?
      column_seq
      primary_key_exp
    ')' _? ';' _? {
        def compile
          rst={}
          rst[:name]=name.compile
          rst[:columns]=column_seq.compile
          rst[:primary_key]=primary_key_exp.compile
          [ :create_table, rst ]
        end
    }
  end

  rule column_seq do
    column_exp+ {
      def compile
        elements.map { |e| e.compile }
      end
    }
  end

  rule column_exp do
    _? name _ type:(int_or_float / char_type) unique:(_ UNIQUE)? _? ',' _? {
      def compile
        rst = { :name => name.compile }
        rst.merge! type.compile
        rst[:unique] = true unless unique.text_value.empty?
        rst
      end
    }
  end

  rule primary_key_exp do
    _? PRIMARY _ KEY _? '(' _? name _? ')' _? {
      def compile
        name.compile
      end
    }
  end

  rule int_or_float do
    (INT / FLOAT) {
      def compile
        { :type => text_value.downcase.to_sym }
      end
    }
  end

  rule char_type do
    _? CHAR _? '(' _? number _? ')' _? {
      def compile
        { :type => :char, :length => number.text_value.to_i }
      end
    }
  end

######

  rule drop_table_exp do
    _? DROP _ TABLE _ name _? ';' _? {
      def compile
        [ :drop_table, name.compile ]
      end
    }
  end

######

  rule create_index_exp do
    _? CREATE _ INDEX _ index:name _ ON _ table:name _?
    '(' _? column:name _? ')' _? ';' _? {
      def compile
        [ :create_index,
          { :name => index.compile,
            :table => table.compile,
            :column => column.compile
          }
        ]
      end
    }
  end

######

  rule drop_index_exp do
    _? DROP _ INDEX _ index:name _? ';' _? {
      def compile
        [ :drop_index, index.compile ]
      end
    }
  end

######

  rule select_exp do
    _? SELECT _ columns:(star / name_seq) _ FROM _ name
    where:(_ where_clause)?
    _? ';' _? {
      def compile
        [ :select,
          { :table => name.compile,
            :columns => columns.compile,
          }.merge!(where_hash)
        ]
      end
      def where_hash
        where.text_value.empty? ? {} : {:where => where.where_clause.compile}
      end
    }
  end

  rule star do
    '*' {
      def compile
        :*
      end
    }
  end

  rule where_clause do
    WHERE _ head:where_condition tail:(AND _ where:where_condition)* {
      def compile
        Set.new [ head.compile, *tail.elements.map{|e| e.where.compile} ]
      end
    }
  end

  rule where_condition do
    name _? where_op _? value {
      def compile
        [ where_op.compile, name.compile, value.compile ]
      end
    }
  end

  rule where_op do
    '=' / '<>' / '<' / '>' / '<=' / '>=' {
      def compile
        case text_value
        when '=' then :'=='
        when '<>' then :'!='
        else text_value.to_sym
        end
      end
    }
  end

######

  rule value do
    number / float_number / string_literal
  end

  rule float_number do
    number '.' number {
      def compile
        text.to_f
      end
    }
  end

  rule string_literal do
    "'" string:(!"'" . )* "'" {
      def compile
        string.text_value
      end
    }
  end

  rule name_seq do
    head:name _? tail:(',' _? name)* {
      def compile
        [ head.compile, *tail.elements.map{|e| e.name.compile} ]
      end
    }
  end

  rule name do
    [a-zA-Z_] [0-9a-zA-Z_]* {
      def compile
        text_value.to_sym
      end
    }
  end

  rule number do
    [1-9] [0-9]*
  end

  rule _ do
    [ \n\r\t]+
  end


  rule AND do 'and' / 'AND' end
  rule CHAR do 'char' / 'CHAR' end
  rule CREATE do 'create' / 'CREATE' end
  rule DROP do 'drop' / 'DROP' end
  rule FLOAT do 'float' / 'FLOAT' end
  rule FROM  do 'from' / 'FROM' end
  rule INDEX do 'index' / 'INDEX' end
  rule INT do 'int' / 'INT' end
  rule KEY do 'key' / 'KEY' end
  rule ON do 'on' / 'ON' end
  rule PRIMARY do 'primary' / 'PRIMARY' end
  rule SELECT do 'select' / 'SELECT' end
  rule TABLE do 'table' / 'TABLE' end
  rule UNIQUE do 'unique' / 'UNIQUE' end
  rule WHERE do 'where' / 'WHERE' end

end

end

# vim: filetype=ruby
